{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"pylite3","text":"<p>Fast, Zero-Copy Python bindings for lite3.</p> <p> </p> <p><code>pylite3</code> provides high-performance access to <code>lite3</code> formatted data. It follows the lazy-parsing philosophy (similar to <code>pysimdjson</code> or <code>simdjson</code>), allowing you to access specific fields in large documents instantly without paying the cost of full deserialization.</p> <p>Data is read directly from the underlying memory buffer\u2014Zero Copy.</p>"},{"location":"#key-features","title":"\ud83d\ude80 Key Features","text":"<ul> <li>Zero-Copy Loading: Creates a proxy object in microseconds, regardless of document size.</li> <li>Lazy Access: Values are only materialized to Python objects when you ask for them.</li> <li>Memory Safe: Automatically manages the lifetime of the underlying buffer using Python's reference counting.</li> <li>Pythonic API: Works like a <code>dict</code> (keys/values/items) or <code>list</code> (slicing/indexing), but faster.</li> <li>Native Hooks: Supports <code>object_hook</code>, <code>default</code>, and more for custom serialization/deserialization.</li> <li>Recursive Writers: Includes a <code>dumps()</code> function to serialize complex nested Python structures into <code>lite3</code>.</li> </ul>"},{"location":"#benchmarks","title":"\u26a1 Benchmarks","text":"<p>Comparison vs <code>pysimdjson</code> for initial load time. Because <code>pylite3</code> is lazy, it returns control to your program immediately.</p> Dataset Size pysimdjson (Parse) pylite3 (Lazy) Speedup canada.json 2.25 MB 68,768 \u00b5s 5.7 \u00b5s 12,047x citm_catalog.json 1.72 MB 49,471 \u00b5s 3.6 \u00b5s 13,803x twitter.json 631 KB 24,189 \u00b5s 2.0 \u00b5s 12,354x <p>See Design &amp; Performance for more details.</p>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>Requires a C compiler and Python 3.9+.</p> <pre><code># From PyPI (recommended)\nuv pip install pylite3\n\n# Build from source\ngit clone --recurse-submodules https://github.com/fastserial/pylite3.git\ncd pylite3\ngit submodule update --init --recursive  # if needed\nuv pip install -e .\n</code></pre>"},{"location":"#usage","title":"\ud83d\udee0 Usage","text":""},{"location":"#notes","title":"Notes","text":"<ul> <li><code>pylite3.loads(...)</code> uses a Lite3 fast-path and falls back to <code>json.loads(...)</code> for non-Lite3 inputs.</li> <li><code>pylite3.dumps(...)</code> returns Lite3 <code>bytes</code> on success; otherwise it falls back to <code>json.dumps(...)</code> and returns <code>str</code> by default.</li> <li>Use <code>fallback=\"raise\"</code> to disable the JSON fallback.</li> </ul>"},{"location":"#reading-data","title":"Reading Data","text":"<pre><code>import pylite3\n\n# Assume 'data' is bytes containing encoded lite3 data\nobj = pylite3.loads(data)\n\n# Access fields instantly\nprint(obj[\"users\"][0][\"name\"])  # 'John Doe'\n\n# Check types without converting\nif obj[\"metadata\"].is_object:\n    print(\"Metadata found\")\n\n# Iterate object keys (new!)\nfor key in obj[\"users\"][0]:\n    print(f\"User key: {key}\")\n\n# Slicing support (new!)\nfirst_two_users = obj[\"users\"][:2]\n\n# Convert to standard dictionary\nuser_dict = dict(obj[\"users\"][0])  # or .as_dict()\n</code></pre>"},{"location":"#writing-data","title":"Writing Data","text":"<pre><code>import pylite3\n\npayload = {\n    \"id\": 12345,\n    \"features\": [\"lazy\", \"fast\"],\n    \"meta\": {\"version\": 2.0}\n}\n\n# Serialize to bytes\nencoded_bytes = pylite3.dumps(payload)\n</code></pre>"},{"location":"#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>\ud83d\udce5 Installation Guide</li> <li>\ud83d\udee0 Usage</li> <li>\ud83d\udcd6 API Reference</li> <li>\ud83c\udfd7 Design &amp; Performance</li> <li>\u2753 FAQ</li> </ul>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions are welcome! Please check the <code>Makefile</code> for useful development commands.</p> <pre><code>make install    # Install dependencies\nmake build      # Compile extension\nmake benchmark  # Run verification\nmake test       # Run E2E tests\nmake coverage   # Generate coverage report\n</code></pre>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#top-level-functions","title":"Top-level functions","text":""},{"location":"api/#pylite3loadsdata-recursivefalse-clsnone-object_hooknone-parse_floatnone-parse_intnone-parse_constantnone-object_pairs_hooknone-kwargs","title":"<code>pylite3.loads(data, *, recursive=False, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kwargs)</code>","text":"<p>Behaves like <code>json.loads</code> with a Lite3 fast-path:</p> <ul> <li>If <code>data</code> is valid Lite3, returns a <code>Lite3Object</code> proxy by default.</li> <li>If <code>recursive=True</code>, returns fully materialized Python objects (<code>dict</code>/<code>list</code>/scalars).</li> <li>If <code>data</code> is not Lite3, falls back to <code>json.loads(...)</code>.</li> </ul> <p>Supported Lite3 inputs include <code>bytes</code>, <code>bytearray</code>, and <code>memoryview</code>.</p>"},{"location":"api/#pylite3dumpsobj-defaultnone-fallbackjson-kwargs","title":"<code>pylite3.dumps(obj, *, default=None, fallback=\"json\", **kwargs)</code>","text":"<p>Serializes Python values into Lite3 bytes when possible.</p> <ul> <li>On success: returns <code>bytes</code> (Lite3-encoded).</li> <li>On failure:</li> <li><code>fallback=\"json\"</code> (default): returns <code>json.dumps(...)</code> as <code>str</code>.</li> <li><code>fallback=\"raise\"</code>: raises the original exception.</li> </ul> <p>Lite3 encoding supports (native): <code>dict</code>, <code>list</code>/<code>tuple</code>, <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code>, <code>bytes</code>.</p> <p>Notes: - Root must be a <code>dict</code> or <code>list</code>/<code>tuple</code> for Lite3 encoding. - Object keys must be <code>str</code> and must not contain NUL (<code>\"\\0\"</code>).</p>"},{"location":"api/#lite3object","title":"<code>Lite3Object</code>","text":"<p><code>Lite3Object</code> is a lazy proxy over Lite3-encoded data. It holds a reference to the underlying buffer to keep it alive and prevent unsafe mutation while the proxy exists.</p>"},{"location":"api/#properties","title":"Properties","text":"<ul> <li><code>.is_object</code>, <code>.is_array</code></li> <li><code>.is_null</code>, <code>.is_bool</code>, <code>.is_int</code>, <code>.is_float</code>, <code>.is_str</code>, <code>.is_bytes</code></li> <li><code>.is_valid</code></li> </ul>"},{"location":"api/#mapping-like-behavior-objects","title":"Mapping-like behavior (objects)","text":"<ul> <li><code>len(obj)</code> returns key count</li> <li><code>obj[\"key\"]</code> returns scalars or nested <code>Lite3Object</code></li> <li><code>\"key\" in obj</code> is supported and fast</li> <li><code>obj.get(\"key\", default=None)</code></li> <li><code>obj.keys()</code>, <code>obj.values()</code>, <code>obj.items()</code></li> <li>Iteration: <code>for k in obj</code> yields keys</li> </ul>"},{"location":"api/#sequence-like-behavior-arrays","title":"Sequence-like behavior (arrays)","text":"<ul> <li><code>len(arr)</code> returns element count</li> <li><code>arr[i]</code> and <code>arr[-1]</code> (negative indices supported)</li> <li><code>arr[1:10:2]</code> returns a Python <code>list</code></li> <li>Iteration: <code>for v in arr</code> yields values</li> </ul>"},{"location":"api/#recursive-conversion","title":"Recursive conversion","text":"<ul> <li><code>obj.to_python(...)</code> recursively converts to standard Python structures</li> <li><code>obj.as_dict()</code> / <code>obj.as_list()</code> are typed convenience wrappers</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#development-setup","title":"Development setup","text":"<pre><code>uv sync --group dev\nuv pip install -e .\n</code></pre>"},{"location":"contributing/#useful-commands","title":"Useful commands","text":"<pre><code>uv run pytest\nuv build --sdist\nmake build\nmake benchmark\n</code></pre>"},{"location":"contributing/#submodules","title":"Submodules","text":"<p>The lite3 C library is included as a git submodule under <code>vendor/lite3</code>.</p> <p>When cloning for development:</p> <pre><code>git clone --recurse-submodules https://github.com/fastserial/pylite3.git\n</code></pre> <p>If you already cloned without submodules:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"design/","title":"Design and Performance","text":""},{"location":"design/#zero-copy-architecture","title":"Zero-Copy Architecture","text":"<p><code>pylite3</code> is designed for extreme performance by avoiding memory copying whenever possible. When you call <code>loads(bytes)</code>, it does not parse the entire buffer. Instead, it creates a lightweight <code>Lite3Object</code> proxy that points to the data within the original byte buffer.</p>"},{"location":"design/#how-it-works","title":"How it works","text":"<ol> <li>Lazy Evaluation: Values are only decoded when you access them (e.g., <code>obj[\"user\"][\"id\"]</code>).</li> <li>Memory Safety: The <code>Lite3Object</code> holds a reference to a stable exported buffer (internally a <code>memoryview</code>), which keeps the underlying memory alive and prevents unsafe mutation while any proxy exists.</li> <li>No Intermediate Structures: Standard JSON parsers typically build a massive tree of Python <code>dict</code> and <code>list</code> objects. <code>pylite3</code> reads directly from the binary buffer, bypassing this expensive allocation phase.</li> </ol>"},{"location":"design/#correctness-and-portability-notes","title":"Correctness and portability notes","text":"<ul> <li>Scalar decoding uses lite3\u2019s accessor functions (which use <code>memcpy</code>) to avoid unaligned/UB reads on strict-alignment platforms.</li> <li><code>loads()</code> performs early sanity checks on the root value so malformed inputs fail cleanly instead of crashing.</li> </ul>"},{"location":"design/#benchmarks","title":"Benchmarks","text":"<p>Because of its lazy nature, <code>pylite3</code>'s distinct advantage is in \"Time to First Byte\" or random access patterns.</p> Dataset Size pysimdjson (Parsing) pylite3 (Lazy Load) Speedup canada.json 2.25 MB ~68 ms ~5.7 \u00b5s 12,047x twitter.json 631 KB ~24 ms ~2.0 \u00b5s 12,354x"},{"location":"design/#when-to-use-pylite3","title":"When to use <code>pylite3</code>?","text":"<ul> <li>High Throughput: You have massive streams of data but only need to inspect a few fields.</li> <li>Memory Constrained: You can't afford to de-serialize large blobs into 5x-10x larger Python dictionary structures.</li> <li>Random Access: You need to grab a value at <code>obj[\"data\"][0][\"id\"]</code> without parsing the gigabytes of irrelevant data surrounding it.</li> </ul>"},{"location":"design/#writing-performance","title":"Writing performance","text":"<p><code>dumps()</code> uses the lite3 writer API and grows its internal buffer as needed. For small objects, this avoids allocating large fixed buffers per call.</p>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#why-does-loadsbjson-return-a-dict","title":"Why does <code>loads(b\"{...json...}\")</code> return a <code>dict</code>?","text":"<p>Because JSON bytes are not Lite3-encoded data, so <code>pylite3.loads</code> falls back to <code>json.loads(...)</code>.</p> <p>If you want Lite3 for a JSON file, load JSON first and then encode:</p> <pre><code>import json\nimport pylite3\n\nobj = json.loads(b'{\"a\": 1}')\ndata = pylite3.dumps(obj, fallback=\"raise\")\n</code></pre>"},{"location":"faq/#how-do-i-force-lite3-only-behavior","title":"How do I force Lite3-only behavior?","text":"<p>Use <code>dumps(..., fallback=\"raise\")</code> so it raises if Lite3 encoding fails instead of returning a JSON string.</p> <p><code>loads()</code> currently falls back to JSON for non-Lite3 inputs by design.</p>"},{"location":"faq/#does-lite3object-copy-the-input-buffer","title":"Does <code>Lite3Object</code> copy the input buffer?","text":"<p>No. It holds a reference to the original buffer and reads values on demand (lazy materialization).</p>"},{"location":"faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<p><code>pylite3</code> is a C extension targeting CPython 3.9+. Wheels are produced in GitHub Actions releases for Linux/macOS/Windows.</p> <p>If you don\u2019t see a wheel for your platform, you can build from source (requires a compiler).</p>"},{"location":"installation/","title":"Installation","text":"<p><code>pylite3</code> is a Cython extension that requires compilation.</p>"},{"location":"installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9+</li> <li>C Compiler (Clang on macOS, GCC on Linux, MSVC on Windows)</li> <li><code>uv</code> (recommended) or <code>pip</code></li> </ul>"},{"location":"installation/#install-from-pypi","title":"Install from PyPI","text":"<p>If a wheel is available for your platform:</p> <pre><code>uv pip install pylite3\n</code></pre>"},{"location":"installation/#installing-from-source","title":"Installing from Source","text":"<ol> <li> <p>Clone the repository:    <pre><code>git clone --recurse-submodules https://github.com/fastserial/pylite3.git\ncd pylite3\ngit submodule update --init --recursive  # if needed\n</code></pre></p> </li> <li> <p>Install with <code>uv</code> (Recommended):    <pre><code># Create virtual environment and install in editable mode\nuv pip install -e .\n</code></pre></p> </li> <li> <p>Install with <code>pip</code>:    <pre><code>pip install .\n</code></pre></p> </li> </ol>"},{"location":"installation/#development-setup","title":"Development Setup","text":"<p>For contributors who want to run benchmarks or modify the Cython bindings:</p> <pre><code># Install dependencies\nuv sync --group dev\n\n# Build in-place\nmake build\n\n# Run benchmarks\nmake benchmark\n\n# Run tests\nuv run pytest\n\n# Generate coverage report\nmake coverage\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#quickstart","title":"Quickstart","text":"<pre><code>import pylite3\n\ndata = pylite3.dumps({\"users\": [{\"id\": 1, \"name\": \"Ada\"}]})\nobj = pylite3.loads(data)\n\nprint(obj[\"users\"][0][\"name\"])  # \"Ada\"\n</code></pre>"},{"location":"usage/#loads-behavior","title":"<code>loads()</code> behavior","text":"<p><code>pylite3.loads(data)</code> is designed to behave like <code>json.loads</code>, but with a fast-path:</p> <ul> <li>If <code>data</code> is valid Lite3 bytes, it returns a lazy <code>Lite3Object</code> proxy (unless <code>recursive=True</code>).</li> <li>Otherwise, it falls back to <code>json.loads(...)</code>.</li> </ul> <p>Supported Lite3 inputs include <code>bytes</code>, <code>bytearray</code>, and <code>memoryview</code>.</p> <pre><code>import json\nimport pylite3\n\njson_bytes = b'{\"a\": 1, \"b\": [1, 2, 3]}'\n\n# Not Lite3 -&gt; fallback to json.loads -&gt; returns dict\nassert pylite3.loads(json_bytes) == {\"a\": 1, \"b\": [1, 2, 3]}\n\n# Convert JSON -&gt; Lite3 explicitly\nlite3_bytes = pylite3.dumps(json.loads(json_bytes), fallback=\"raise\")\nobj = pylite3.loads(lite3_bytes)\nassert obj[\"b\"][0] == 1\n</code></pre>"},{"location":"usage/#lite3object-basics","title":"<code>Lite3Object</code> basics","text":""},{"location":"usage/#objects-dict-like","title":"Objects (dict-like)","text":"<pre><code>obj = pylite3.loads(pylite3.dumps({\"a\": 1, \"b\": 2}))\n\nassert len(obj) == 2\nassert \"a\" in obj\nassert obj.get(\"missing\", 123) == 123\n\nfor k in obj:\n    print(k)  # keys\n</code></pre>"},{"location":"usage/#arrays-list-like","title":"Arrays (list-like)","text":"<pre><code>arr = pylite3.loads(pylite3.dumps([10, 20, 30]))\n\nassert arr[0] == 10\nassert arr[-1] == 30\nassert arr[0:2] == [10, 20]\n\nfor v in arr:\n    print(v)\n</code></pre>"},{"location":"usage/#recursive-conversion","title":"Recursive conversion","text":"<pre><code>data = pylite3.dumps({\"a\": [1, {\"b\": 2}]})\nobj = pylite3.loads(data)\n\nassert obj.as_dict() == {\"a\": [1, {\"b\": 2}]}\nassert pylite3.loads(data, recursive=True) == {\"a\": [1, {\"b\": 2}]}\n</code></pre>"},{"location":"usage/#dumps-behavior-and-fallback","title":"<code>dumps()</code> behavior and fallback","text":"<p><code>pylite3.dumps(...)</code> tries to produce Lite3 <code>bytes</code>. If Lite3 serialization fails, it falls back to <code>json.dumps(...)</code> and returns a <code>str</code> by default.</p> <p>To disable fallback:</p> <pre><code>import pylite3\n\nclass X: ...\n\ntry:\n    pylite3.dumps({\"x\": X()}, fallback=\"raise\")\nexcept Exception:\n    pass\n</code></pre> <p>Notes: - Lite3 serialization supports: <code>dict</code>, <code>list</code>/<code>tuple</code>, <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>None</code>, <code>bytes</code>. - Root must be a <code>dict</code> or <code>list</code>/<code>tuple</code> for Lite3 encoding. - Object keys must be <code>str</code> and must not contain NUL (<code>\"\\0\"</code>).</p>"}]}